# 랭킹 및 비동기 대기열 시스템 설계(개선) 및 개발 후 회고 보고서

## 1. 개요
이번 과제는 콘서트 예약 시스템의 성능 및 유연성을 개선하기 위해 다음 두 가지 핵심 컴포넌트를 설계 및 개발하는 것을 목표로 하였습니다.
- 랭킹 시스템 : 사용자 활동(예약 등)에 기반하여 콘서트의 인기 순위를 일간/주간/월간 단위로 계산하고 제공
- Redis 기반 대기열 시스템 (비동기 만료 감지 포함) : 기존 DB 중심의 대기열 구조를 Redis로 이전하고, TTL 만료를 비동기적으로 감지해 활성 토큰을 자동 제거하는 구조로 개선

## 2. 시스템별 설계 및 구현
### 2.1 랭킹 시스템 
 🎯 목적

 콘서트 예약 시 특정 점수를 부여하고, 해당 데이터를 기반으로 콘서트 랭킹을 주기적으로 집계 및 조회할 수 있도록 함.

🗂️ 데이터 구조 및 키 구성

- 일간 랭킹 저장: ZSET – concert:ranking:{yyyyMMdd}

- 집계 랭킹 저장: LIST – concert:ranking:{daily|weekly|monthly}

⚙️ 집계 및 저장 로직
- 매일 00시에 스케줄러 실행
- 최근 N일간의 ZSet 키를 수집하여 ZUNIONSTORE 방식으로 점수 합산
- 랭킹된 콘서트 ID를 바탕으로 DB에서 상세 정보 조회
- JSON으로 직렬화 후 Redis List에 저장 (TTL: 1일)

💡 구현 특징
- 조회 시 캐싱된 List에서 바로 읽어 빠른 응답 제공
- ObjectMapper를 이용한 콘서트 정보 JSON 변환


### 2.2 Redis 기반 대기열 시스템
🎯 목적
기존 DB 중심 대기열 시스템의 한계를 개선하고, Redis의 TTL 및 이벤트 리스닝 기능을 활용하여 반응성과 확장성을 확보함.

🗂️ 데이터 구조 및 키 구성
- 사용자 정보(id) : String - queue:user:{token}
- 대기열 토큰 리스트 : List - queue:waiting
- 활성 토큰 리스트 : List - queue:active
- 활성 토큰 TTL : String - queue:ttl:{token}

⚙️ 처리 흐름
 - 대기열 생성
    - 사용자가 접근 시 토큰을 생성하여 Redis에만 저장
    - RDB 저장은 생략 (TTL 만료되는 특성 + 속도 우위 때문)
- 활성 토큰 전환
  - 1분 주기의 스케줄러로 활성 슬롯 확인
  - 빈 슬롯이 있으면 대기열에서 첫 토큰을 활성 리스트로 이동 후 TTL 부여 
- TTL 만료 감지 및 자동 제거 
  - Redis 설정: CONFIG SET notify-keyspace-events Ex
  - KeyExpiredListener를 통해 queue:ttl:{token} 만료 감지
  - 감지 시 queue:active에서 해당 토큰 제거

## 회고
- 잘한 점
  - 시스템에 적합한 Redis 자료구조 선정: ZSet, List, String을 활용
  - TTL과 만료 이벤트 기반으로 비동기 처리 흐름을 구성한 점은 기존 polling 기반 구조보다 효율적
  - 랭킹 시스템은 정렬된 데이터를 캐시해 빠르게 조회 가능하도록 구성
- 아쉬운 점
  - 랭킹 시스템 TTL과 스케줄링 시간 불일치 가능성 존재 → TTL을 1일 이상으로 설정하거나 보정 로직 도입 고려
  - 단순 score 합산이 아닌 가중치 기반 랭킹 산정 고려 필요 (예: 최근 활동에 가중치 부여 등)
  - 대기열 구조가 복잡해질 경우 Set 또는 ZSet을 활용한 시간 기반 정렬 구조로 확장 가능

이번 과제를 통해 Redis 기반의 구조 설계 및 TTL 이벤트 활용에 대한 실전 경험을 쌓을 수 있었으며, 단순한 구현을 넘어서 데이터의 수명, 조회 성능, 확장성에 대한 고민을 설계에 반영하려 노력했습니다.
